#! /usr/bin/python3.7

import tempfile
import croniter
from datetime import datetime
from datetime import timedelta

import os
import argparse
import subprocess
from lxml import etree
from colorama import Fore, Back, Style
import signal
import sys
import time

__VERSION__ = "1.0.0";
__ROOTDIR__ = os.path.dirname(os.path.dirname(os.path.abspath(__file__)));

def wait(plist = [], **kwargs):

    timeout  = kwargs.get("timeout",  5);
    attempts = kwargs.get("attempts", 10);
    pidfile  = kwargs.get("pidfile",  None);
    cwd      = kwargs.get("cwd",  ".");
    verbose  = kwargs.get("verbose",  False);

    plist_attempt = [];
    for p in plist:
        plist_attempt.append(attempts);

    plist_crash = [];
    for p in plist:
        plist_crash.append(False);

    time.sleep(0.5);
    while True:

        # If all attempt are zeros
        if all(attempt == 0 for attempt in plist_attempt):
            print(Fore.RED + "   * All servers crashed, too many attempts, abort..");
            break;

        for k in range(len(plist)):

            p = plist[k]["process"];
            cmd = p.args;
            poll = p.poll();

            now = datetime.now();
            cron = plist[k]["cron"];
            if (cron):

                # Determine next sched
                if (not "next" in plist[k]):
                    plist[k]["next"] = datetime.strptime(str(cron.get_next(datetime)), "%Y-%m-%d %H:%M:%S");

                # Timeout, command needs to be submitted
                if (verbose):
                    print(Fore.YELLOW+ "     Cronjob waiting [" + ' '.join(cmd) + "]:"+Style.RESET_ALL+" Next iteration at " + str(plist[k]["next"]) + Style.RESET_ALL);

                if ((plist[k]["next"] - now) < timedelta(0)):
                    plist[k]["next"] = None;

                    # If command still running.. kill it first..
                    if(poll is None):
                        print(Fore.RED+"     Cronjob is about to be executed.. killing current process"+Style.RESET_ALL);
                        plist[k]["process"].terminate();
                        time.sleep(timeout);
                        plist[k]["process"].kill();

                    # Resubmit command..
                    pidfile = open(pidfile.name, "w+")
                    plist[k]["process"] = send_command([cmd], pidfile=pidfile, verbose=plist[k]["verbose"], cwd=plist[k]["cwd"], stdout=plist[k]["stdout"], stderr=plist[k]["stderr"])[0]["process"];
                    pidfile.close();

                    # Notify and prepare for next iteration
                    print(Fore.GREEN+ "     Cronjob launched [" + str(plist[k]["cmd"]) + "]:"+Style.RESET_ALL+" New daemon [" + str(plist[k]["process"].pid) + "]" + Style.RESET_ALL);
                    del plist[k]["next"];

            # Resubmit if crashed..
            elif not poll is None:

                if(not plist_crash[k]):
                    print(Fore.RED + "   * Daemon [" + str(p.pid) + "] just crashed.." + Style.RESET_ALL);
                    plist_crash[k] = True;

                if(plist_attempt[k]):

                    pidfile = open(pidfile.name, "w+")
                    plist[k]["process"] = send_command([p.args], pidfile=pidfile, verbose=plist[k]["verbose"], cwd=plist[k]["cwd"], stdout=plist[k]["stdout"], stderr=plist[k]["stderr"])[0]["process"];
                    pidfile.close();

                    plist_attempt[k] = plist_attempt[k] - 1;
                    print(Fore.YELLOW + "     Attempt to restart [" + str(p.pid) + "]:"+Style.RESET_ALL+" New daemon [" + str(plist[k]["process"].pid) + "] ("+str(attempts-plist_attempt[k])+"/"+str(attempts)+")" + Style.RESET_ALL);
                    plist_crash[k] = False;


        # Wait before next attempt
        time.sleep(timeout)
        if timeout <= 0: break;

    return [p.wait() for p in plist];

def send_command(cmdlist, **kwargs):

    verbose = kwargs.get("verbose", False);
    pidfile = kwargs.get("pidfile", None);

    cwd     = kwargs.get("cwd", None);
    wd      = os.getcwd()
    os.chdir(cwd)

    spec = kwargs.get("spec", None);
    stdout  = kwargs.get("stdout", None);
    stderr  = kwargs.get("stderr", stdout);

    plist = [];
    for cmd in cmdlist:
        p = subprocess.Popen(cmd if type(cmd) == list else cmd.split(' '),
                stdout=open(stdout, "w+") if type(stdout) == str else stdout,
                stderr=open(stderr, "w+") if type(stderr) == str else stderr, cwd=cwd);

        plist.append({
            "process":p, "stdout":stdout,"stderr":stderr,
            "cwd":cwd, "pidfile":pidfile, "verbose":verbose,
            "cron":croniter.croniter(spec, datetime.now()) if spec else None
        });


        if(verbose): print("@subprocess: "+ " ".join(cmd) + "; @return "+plist[-1]["process"].communicate()[0].strip().decode("utf-8"));
        if(pidfile): pidfile.write(" "+str(plist[-1]["process"].pid));

    os.chdir(wd)

    return plist;

def parse_xml(xmlfile):

    d = {};
    tree = etree.parse(xmlfile)

    for app in tree.xpath("//symfony/application"):

        path = app.get("path");
        if(path in d):
            print("This application already exists.. "+path, file=sys.stderr);
            exit(1);

        d[path] = {};
        d[path]["port"]   = app.get("port");

        d[path]["workers"] = [];
        for worker in app.xpath("worker"):
            d[path]["workers"].append({"transport": worker.get("transport")});

        d[path]["crontab"] = [];
        for cron in app.xpath("cron"):
            d[path]["crontab"].append({"name": cron.get("name"), "cmd": cron.get("cmd"), "spec": cron.get("spec")});

    return d;

def mktemp(**kwargs):
    prefix=kwargs.get("prefix","");
    suffix=kwargs.get("suffix","");
    return tempfile._get_default_tempdir() + "/" + prefix + next(tempfile._get_candidate_names()) + suffix;

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Symfony Autoserve Arguments')
    parser.add_argument('--config', type=str,
                        default="/etc/symfony.xml",
                        help='Provide XML configuration file')
    parser.add_argument('--pidfile', type=str, default=mktemp(prefix="symfony-", suffix=".pid"),
                        help='Provide PID file for daemonize subprocess')
    parser.add_argument('--attempt', type=int, default=10,
                        help='Number of reconnection before giving up')
    parser.add_argument('--timeout', type=int, default=4,
                        help='Timeout before retrying to connect')

    args = parser.parse_args()
    symfony = parse_xml(args.config);

    attempt = args.attempt;
    timeout = args.timeout;

    pidfile = args.pidfile;
    if(type(pidfile) == str): pidfile = open(pidfile,"w");

    print(Fore.MAGENTA + "-- Symfony Autoserve v"+__VERSION__+Style.RESET_ALL);
    print(Fore.GREEN + "-- Project Directory: "+Style.RESET_ALL + __ROOTDIR__);
    print(Fore.GREEN + "-- XML Configuration File: "+Style.RESET_ALL + args.config);
    if(pidfile): print(Fore.GREEN + "-- Writing PID here: "+ Style.RESET_ALL+ pidfile.name);

    print(Fore.MAGENTA + "-- Starting server(s):"+ Style.RESET_ALL)
    if(pidfile): pidfile.write(str(os.getpid()));

    plist = [];
    for path in symfony:

        # Handle server
        port = symfony[path]["port"];
        plist += send_command(
            ["symfony serve --port " + port],
            cwd=path, pidfile=pidfile,
            stdout="symfony-server.log"
        );
        print(Fore.GREEN + "   * New application: "+ Style.RESET_ALL +path+ " / "+
              Fore.GREEN+"Listening:"+Style.RESET_ALL+
            " https://127.0.0.1:"+port+" / "+Fore.GREEN+"PID:"+Style.RESET_ALL+
            " ["+str(plist[-1]["process"].pid)+"]"+Fore.CYAN+" (logs stored into symfony-server.log)"+Style.RESET_ALL);

        time.sleep(1);

        # Handle message broker
        workers = symfony[path]["workers"];
        print(Fore.GREEN + "     It contains " + str(len(workers)) + " worker(s): "+ Style.RESET_ALL + str([w["transport"] for w in workers])+Fore.CYAN+" (logs stored into symfony-messenger.log)"+Style.RESET_ALL)
        for worker in workers:
            plist += send_command(
                ["symfony console messenger:consume " + worker["transport"] + " -vv"],
                cwd=path, pidfile=pidfile, stdout="symfony-messenger.log"
            );

        # Handle CRONTAB
        crontab = symfony[path]["crontab"];
        print(Fore.GREEN + "     and also " + str(len(crontab)) + " cron task(s): "+ Style.RESET_ALL + str([cron["name"] for cron in crontab]) +Fore.CYAN+" (logs stored into symfony-crontab.log)"+Style.RESET_ALL);
        for cron in crontab:
            print(cron["cmd"]);
            plist += send_command(
                [cron["cmd"]], spec=cron["spec"],
                cwd=path, pidfile=pidfile, stdout="symfony-crontab.log"
            );

    if(pidfile):
         pidfile.close();

    def signal_handler(sig, frame):
        print('You pressed Ctrl+C.. Killing Symfony services..')
        for p in plist:
            os.killpg(os.getpgid(p["process"].pid), signal.SIGTERM)

    signal.signal(signal.SIGINT, signal_handler)
    print('   * Press Ctrl+C to exit');

    print(Fore.MAGENTA + "-- Daemon status:"+ Style.RESET_ALL)
    wait(plist, attempt=attempt, timeout=timeout, cwd=path, pidfile=pidfile);
