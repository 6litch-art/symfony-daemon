#! /usr/bin/python3.7

import tempfile
import croniter
from datetime import datetime
from datetime import timedelta

import os
import argparse
import subprocess
from lxml import etree
from colorama import Fore, Back, Style
import signal
import sys
import time

__VERSION__ = "1.0.0";
__ROOTDIR__ = os.path.dirname(os.path.dirname(os.path.abspath(__file__)));

def get_cache_info(directory):
    directory += "/var/cache";
    file_list = []
    for i in os.listdir(directory):
        a = os.stat(os.path.join(directory,i))
        file_list.append([i,time.ctime(a.st_atime),time.ctime(a.st_ctime)]) #[file,most_recent_access,created]
    return file_list

def wait(plist = [], **kwargs):

    timeout  = kwargs.get("timeout",  5);
    attempts = kwargs.get("attempts", 10);
    pidfile  = kwargs.get("pidfile",  None);
    cwd      = kwargs.get("cwd",  ".");
    verbosity  = kwargs.get("verbosity",  False);

    plist_attempt = [];
    for p in plist:
        plist_attempt.append(attempts);

    plist_crash = [];
    for p in plist:
        plist_crash.append(False);

    time.sleep(0.5);
    while True:

        # If all attempt are zeros
        if all(attempt == 0 for attempt in plist_attempt):
            print(Fore.RED + "   * All servers crashed, too many attempts, abort..");
            break;

        for k in range(len(plist)):

            p    = plist[k]["process"];
            cwd  = plist[k]["cwd"];

            cmd  = p.args;
            poll = p.poll();

            now  = datetime.now();
            cron = plist[k]["cron"];
            if (cron):

                # Determine next sched
                if (not "next" in plist[k]):
                    plist[k]["next"] = datetime.strptime(str(cron.get_next(datetime)), "%Y-%m-%d %H:%M:%S");

                # Check if a cache has been cleaned
                cache = get_cache_info(cwd);
                if(plist[k]["cache"] != cache):
                    plist[k]["next"] = now - timedelta(1);
                    plist[k]["cache"] = cache;
                    time.sleep(warmup);

                # Timeout, command needs to be submitted
                if (verbosity):
                    print(Fore.YELLOW+ "     Cronjob waiting [" + ' '.join(cmd) + "]:"+Style.RESET_ALL+" Next iteration at " + str(plist[k]["next"]) + Style.RESET_ALL);

                if ((plist[k]["next"] - now) < timedelta(0)):
                    plist[k]["next"] = None;

                    # If command still running.. kill it first..
                    if(poll is None):
                        if(verbosity): print(Fore.RED+"     Cronjob is about to be executed.. killing current process"+Style.RESET_ALL);
                        plist[k]["process"].terminate();
                        time.sleep(timeout);
                        plist[k]["process"].kill();

                    # Resubmit command..
                    pidfile = open(pidfile.name, "a+")
                    plist[k]["process"] = send_command([cmd], pidfile=pidfile, verbosity=plist[k]["verbosity"], cwd=plist[k]["cwd"], stdout=plist[k]["stdout"], stderr=plist[k]["stderr"])[0]["process"];
                    pidfile.close();

                    # Notify and prepare for next iteration
                    if(verbosity): print(Fore.GREEN+ "     Cronjob launched [" + str(plist[k]["cmd"]) + "]:"+Style.RESET_ALL+" New daemon [" + str(plist[k]["process"].pid) + "]" + Style.RESET_ALL);
                    del plist[k]["next"];

            # Resubmit if crashed..
            elif not poll is None:

                if(not plist_crash[k]):
                    if(verbosity): print(Fore.RED + "   * Daemon [" + str(p.pid) + "] just crashed.." + Style.RESET_ALL);
                    plist_crash[k] = True;

                if(plist_attempt[k]):

                    pidfile = open(pidfile.name, "a+")
                    plist[k]["process"] = send_command([p.args], pidfile=pidfile, verbosity=plist[k]["verbosity"], cwd=plist[k]["cwd"], stdout=plist[k]["stdout"], stderr=plist[k]["stderr"])[0]["process"];
                    pidfile.close();

                    plist_attempt[k] = plist_attempt[k] - 1;
                    if(verbosity): print(Fore.YELLOW + "     Attempt to restart [" + str(p.pid) + "]:"+Style.RESET_ALL+" New daemon [" + str(plist[k]["process"].pid) + "] ("+str(attempts-plist_attempt[k])+"/"+str(attempts)+")" + Style.RESET_ALL);
                    plist_crash[k] = False;

        # Wait before next attempt
        time.sleep(timeout)
        if timeout <= 0: break;

    return [p.wait() for p in plist];

def send_command(cmdlist, **kwargs):

    verbosity = kwargs.get("verbosity", False);
    pidfile = kwargs.get("pidfile", None);

    cwd     = kwargs.get("cwd", None);
    wd      = os.getcwd()
    os.chdir(cwd)

    spec = kwargs.get("spec", None);
    stdout  = kwargs.get("stdout", None);
    stderr  = kwargs.get("stderr", stdout);

    plist = [];
    for cmd in cmdlist:
        p = subprocess.Popen(cmd if type(cmd) == list else cmd.split(' '),
                stdout=open(stdout, "a+") if type(stdout) == str else stdout,
                stderr=open(stderr, "a+") if type(stderr) == str else stderr, cwd=cwd);

        plist.append({
            "process":p, "stdout":stdout,"stderr":stderr,
            "cwd":cwd, "pidfile":pidfile, "verbosity":verbosity, "cache": get_cache_info(cwd),
            "cron":croniter.croniter(spec, datetime.now()) if spec else None
        });


        if(verbosity): print("@subprocess: "+ " ".join(cmd) + "; @return "+plist[-1]["process"].communicate()[0].strip().decode("utf-8"));
        if(pidfile): pidfile.write(" "+str(plist[-1]["process"].pid));

    os.chdir(wd)

    return plist;

def parse_xml(xmlfile):

    d = {};
    tree = etree.parse(xmlfile)

    for app in tree.xpath("//symfony/application"):

        path = app.get("path");
        if(path in d):
            print("This application already exists.. "+path, file=sys.stderr);
            exit(1);

        d[path] = {};
        d[path]["port"]   = app.get("port");

        d[path]["workers"] = [];
        for worker in app.xpath("worker"):
            d[path]["workers"].append({"transport": worker.get("transport")});

        d[path]["crontab"] = [];
        for cron in app.xpath("cron"):
            d[path]["crontab"].append({"name": cron.get("name"), "cmd": cron.get("cmd"), "spec": cron.get("spec")});

    return d;

def mktemp(**kwargs):
    prefix=kwargs.get("prefix","");
    suffix=kwargs.get("suffix","");
    return tempfile._get_default_tempdir() + "/" + prefix + next(tempfile._get_candidate_names()) + suffix;

if __name__ == "__main__":

    #
    # Program usage parser
    #
    parser = argparse.ArgumentParser(description='Symfony Autoserve Arguments')
    parser.add_argument('--config', type=str,
                        default="/etc/symfony.xml",
                        help='Provide XML configuration file')
    parser.add_argument('--pidfile', type=str, default=mktemp(prefix="symfony-", suffix=".pid"),
                        help='Provide PID file for daemonize subprocess')
    parser.add_argument('--attempts', type=int, default=10,
                        help='Number of reconnection before giving up')
    parser.add_argument('--timeout', type=int, default=5,
                        help='Timeout before retrying to connect')
    parser.add_argument('--warmup', type=int, default=5,
                        help='Server warmup timeout')
    parser.add_argument('--verbosity', type=bool, default=False,
                        help='Make program more verbose')
    args      = parser.parse_args()

    #
    # Parse XML file and prepare the main variables
    #
    symfony   = parse_xml(args.config);
    verbosity = args.verbosity;
    attempts   = args.attempts;
    timeout   = args.timeout;
    warmup    = args.warmup;

    pidfile   = args.pidfile;
    if(type(pidfile) == str): pidfile = open(pidfile,"a+");

    #
    # Print out some important information for logging
    #
    print(Fore.MAGENTA + "-- Symfony Autoserve v"+__VERSION__+Style.RESET_ALL);
    print(Fore.GREEN + "-- Project Directory: "+Style.RESET_ALL + __ROOTDIR__);
    print(Fore.GREEN + "-- XML Configuration File: "+Style.RESET_ALL + args.config);
    if(pidfile): print(Fore.GREEN + "-- Writing PID here: "+ Style.RESET_ALL+ pidfile.name);

    print(Fore.MAGENTA + "-- Starting server(s):"+ Style.RESET_ALL)
    if(pidfile): pidfile.write(str(os.getpid()));

    #
    # Loop over symfony server + start workers (message broker) + run crontab commands (e.g. cache)
    #
    plist = [];
    for path in symfony:

        #
        # Prepare new application
        #
        port = symfony[path]["port"];
        workers = symfony[path]["workers"];
        crontab = symfony[path]["crontab"];

        #
        # Starting server
        #
        plist += send_command(
            ["symfony serve --port " + port],
            cwd=path, pidfile=pidfile,
            stdout="var/log/server.log", verbosity=verbosity
        );

        # Print out some variable
        print(Fore.GREEN + "   * New application: "+ Style.RESET_ALL +path+ " / "+
              Fore.GREEN+"Listening:"+Style.RESET_ALL+
            " https://127.0.0.1:"+port+" / "+Fore.GREEN+"PID:"+Style.RESET_ALL+
            " ["+str(plist[-1]["process"].pid)+"]"+Fore.CYAN+" (logs stored into var/log/server.log)"+Style.RESET_ALL);
        print(Fore.GREEN + "     It contains " + str(len(workers)) + " worker(s): "+ Style.RESET_ALL + str([w["transport"] for w in workers])+Fore.CYAN+" (logs stored into var/log/messenger.log)"+Style.RESET_ALL)
        print(Fore.GREEN + "     and also " + str(len(crontab)) + " cron task(s): "+ Style.RESET_ALL + str([cron["name"] for cron in crontab]) +Fore.CYAN+" (logs stored into var/log/crontab.log)"+Style.RESET_ALL);

        # Wait some time before starting workers
        print(Fore.CYAN  + "   * Warmup time: "+str(warmup)+"s, please wait.." + Style.RESET_ALL);
        time.sleep(warmup);

        #
        # Worker / Message consumer
        #
        for i in range(len(workers)):
            worker = workers[i];
            plist += send_command(
                ["symfony console messenger:consume " + worker["transport"] + " -vv"],
                cwd=path, pidfile=pidfile, stdout="var/log/messenger."+str(i)+".log", verbosity=verbosity
            );

        #
        # Run crontab commands
        #
        for i in range(len(crontab)):
            cron = crontab[i];
            plist += send_command(
                [cron["cmd"]], spec=cron["spec"],
                cwd=path, pidfile=pidfile, stdout="var/log/crontab."+str(i)+".log", verbosity=verbosity
            );

    # Close PID file (this one will be updated later if required..)
    if(pidfile):
         pidfile.close();

    #
    # Catch signal interrupt
    #
    def signal_handler(sig, frame):
        print('You pressed Ctrl+C.. Killing Symfony services..')
        for p in plist:
            os.killpg(os.getpgid(p["process"].pid), signal.SIGTERM)
    signal.signal(signal.SIGINT, signal_handler)
    print('   * Press Ctrl+C to exit');

    #
    # Wait for the process to finish + resubmit commands if necessary
    #
    if(verbosity): print(Fore.MAGENTA + "-- Daemon status:"+ Style.RESET_ALL)
    wait(plist, attempts=attempts, timeout=timeout, cwd=path, pidfile=pidfile);
